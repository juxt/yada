#+EXPORT_EXCLUDE_TAGS:  noexport
#+AUTHOR:               Malcolm Sparks
#+EMAIL:                @malcolmsparks
#+TITLE:                yada
#+LANGUAGE:             en
#+OPTIONS:              toc:nil
#+OPTIONS:              reveal_center:t reveal_progress:nil reveal_history:t reveal_control:nil
#+OPTIONS:              reveal_mathjax:nil reveal_rolling_links:nil reveal_keyboard:t reveal_overview:t num:nil
#+OPTIONS:              width:1600 height:900
#+REVEAL_HLEVEL:        1
#+REVEAL_MARGIN:        0.0
#+REVEAL_MIN_SCALE:     1.0
#+REVEAL_MAX_SCALE:     1.4
#+REVEAL_THEME:         juxt
#+REVEAL_TRANS:         none
#+REVEAL_SPEED:         fast
#+REVEAL_ROOT:          static
#+REVEAL_PLUGINS: (highlight markdown notes pdf)
#+REVEAL_EXTRA_CSS: static/css/fby-2016.css

* HTTP: The printing press of our age

#+BEGIN_NOTES
From a historical perspective

DNA?
The age of the universe?
HTTP?
#+END_NOTES

- URIs - universal address system for information
- HTTP - universal information retrieval system
- HTML - retrieval and navigation for humans

#+BEGIN_NOTES
#+END_NOTES

* HTTP: the choice of a new generation

  [[./static/assets/amazon-echo-dot-white.jpg]]

#+BEGIN_NOTES
Now the web has become truly industrialized, and mechanized - literally - we are seeing machines talk to other machines using HTTP.

A few weeks ago I purchased one of these Amazon things and in a couple of hours was able to program it to add some new tricks. We did it as a family programming exercise. Of course, it was simply HTTP POSTS

#+END_NOTES

* Web frameworks

- Still far too complex!
- So much for the developer to do
- Ambivalent about standards
- We need a better way!

#+BEGIN_NOTES
If

Here's the request, you figure out the response!
#+END_NOTES

* WebMachine - a way forward

  [[./static/assets/http-headers-status-v3.png]]

#+BEGIN_NOTES
# cf. Liberator

# -ve: Surfaces execution model
# -ve: Synchronous

# Can we keep the Liberator HTTP defaults, without exposing developers to the execution model? And that's when the idea for yada was born
#+END_NOTES

* ~yada~

* ~yada~ is declarative

#+BEGIN_SRC clojure big
  {:methods
   {:get
    {:produces "text/html"
     :response (fn [_] "<h1>Hello World!</h1>")}
    :put
    {:consumes "application/json"
     :parameters {:body {:greeting String}}
     :response (fn [ctx] ...)
     }}}
#+END_SRC

#+BEGIN_NOTES
It took a year for this simple idea to dawn on me. The first iteration of yada was actually based on Clojure's records and protocols.

But what could be simpler than Clojure's maps?

This is one of the reasons Clojure is so nice.

If you haven't used Clojure's literal syntax, it's a bit like JSON.

But I find Clojure's syntax much nicer to type than JSON. JSON forces you to use speech-marks around keys, add commas in the right place, but worst of all, stops you writing comments!

Clojure's syntax has all the benefits of JSON - you can generate it, manipulate it with your own programs (swagger), you can serialize it so you can send it over the network.

From this simple declaration we can tell a few things: it produces static HTML.

There's a lot more you can add to a resource declaration, but there's also some schema behind this, so if you make a mistake and put it something that yada doesn't recognise, it will let you know by failing quickly.

#+END_NOTES

* ~yada~ is standards-compliant

- Response status codes and headers
- Content negotiation
- Conditional requests
- Security
- Much more, and more to come

* ~yada~ is linear

available? → known-method? → uri-too-long? → TRACE → method-allowed? → parse-parameters → capture-proxy-headers → authenticate → get-properties → authorize → process-content-encoding → process-request-body → check-modification-time → select-representation → if-match → if-none-match → invoke-method → get-new-properties → compute-etag → access-control-headers → security-headers → create-response → logging → return

- State monad (state is known as /request context/)
- By default, all requests for all routes go through the /same/ chain
- Every interceptor has access to request, whole resource model and any information collected by previous interceptors

* ~yada~ is asynchronous

available? → known-method? → uri-too-long? → TRACE → method-allowed? → parse-parameters → capture-proxy-headers → authenticate → get-properties → authorize → process-content-encoding → process-request-body → check-modification-time → select-representation → if-match → if-none-match → invoke-method → get-new-properties → compute-etag → access-control-headers → security-headers → create-response → logging → return

- /Any/ interceptor can defer its return value (futures, promises, core.async channels)

* ~yada~ is extensible

- Methods
- Media-types
- Interceptors

* ~yada~ is scaleable

- Built upon _aleph_ and _netty_

* Content Negotiation

available? → known-method? → uri-too-long? → TRACE → method-allowed? → parse-parameters → capture-proxy-headers → authenticate → get-properties → authorize → process-content-encoding → process-request-body → check-modification-time → _select-representation_ → if-match → if-none-match → invoke-method → get-new-properties → compute-etag → access-control-headers → security-headers → create-response → logging → return

* 'Data Macros'

#+BEGIN_SRC clojure
{:produces "text/html"}
#+END_SRC

becomes

#+BEGIN_SRC clojure
{:produces
 [{:media-type "text/html"}]}
#+END_SRC

- See https://juxt.pro/blog/posts/data-macros.html

* but you can do

#+BEGIN_SRC clojure
{:produces
 [{:media-type "text/html"
   :charset "UTF-8"
   :language #{"en" "zh-ch;q=0.9"}}
  {:media-type "text/html"
   :charset "Shift_JIS"
   :encoding "gzip"
   :language "zh-ch;q=0.9"}
  {:media-type "text/plain"}]}
#+END_SRC

* Parameter validation

available? → known-method? → uri-too-long? → TRACE → method-allowed? → _parse-parameters_ → capture-proxy-headers → authenticate → get-properties → authorize → process-content-encoding → process-request-body → check-modification-time → select-representation → if-match → if-none-match → invoke-method → get-new-properties → compute-etag → access-control-headers → security-headers → create-response → logging → return

- Attempt to coerce parameters to required types
- If parameters aren't valid, return with a 400

* Conditional Requests

available? → known-method? → uri-too-long? → TRACE → method-allowed? → parse-parameters → capture-proxy-headers → authenticate → _get-properties_ → authorize → process-content-encoding → process-request-body → check-modification-time → select-representation → _if-match_ → _if-none-match_ → invoke-method → _get-new-properties_ → _compute-etag_ → access-control-headers → security-headers → create-response → logging → return

#+BEGIN_SRC clojure

#+END_SRC

* Security

available? → known-method? → uri-too-long? → TRACE → method-allowed? → parse-parameters → capture-proxy-headers → _authenticate_ → get-properties → _authorize_ → process-content-encoding → process-request-body → check-modification-time → select-representation → if-match → if-none-match → invoke-method → get-new-properties → compute-etag → _access-control-headers_ → _security-headers_ → create-response → logging → return

#+BEGIN_SRC clojure

#+END_SRC

* Server sent events

#+BEGIN_SRC clojure
  {:methods
   {:get {:produces "text/event-stream"
          :response (chan)}}}
#+END_SRC

* Uploads

available? → known-method? → uri-too-long? → TRACE → method-allowed? → parse-parameters → capture-proxy-headers → authenticate → get-properties → authorize → _process-content-encoding_ → _process-request-body_ → check-modification-time → select-representation → if-match → if-none-match → invoke-method → get-new-properties → compute-etag → access-control-headers → security-headers → create-response → logging → return

- Fully asynchronous
- Support for form-data/multipart (~200Mb/s)
- Boyer-Moore-Horspool algorithm (modified for streaming)
- Pluggable handlers

#+BEGIN_SRC clojure

#+END_SRC

* Routing

- No support in yada!

#+BEGIN_QUOTE
Routes and Resources should be independent
-- Phillip Meier
#+END_QUOTE

#+BEGIN_NOTES
About 3 years ago, Billy and I were at EuroClojure in Berlin in 2013 and I about whether he would be adding routing to Liberator, without even hesitating he said no!

I asked why. He explained that resources and their names are different concepts and shouldn't be mixed.  I slept on this for a couple of months, a process which we call 'Hammock Driven Development'. It worked, over Christmas I had a sudden moment of inspiration, grabbed the nearest computer and typed out the first version of what became bidi.

#+END_NOTES
* bidi

- A URI router, nothing more
- Recursive pattern matching
- Bidirectional

* bidi example

#+BEGIN_SRC clojure
  ["/phonebook" [
                 ["" :index]
                 [["/" :id] :entry]
                ]]
#+END_SRC

#+BEGIN_SRC clojure
/phonebook -> :index
/phonebook/123 -> :entry
#+END_SRC

#+BEGIN_SRC clojure
:index -> /phonebook
:entry 123 -> /phonebook/123
#+END_SRC

* bidi notes

- Written in December 2013
- ClojureScript support added afterwards
- Fairly established

* ~yada~ is evolving

- clojure.spec
- Instrumentation and debugging
- Environment profiles
- Range requests & partial content
- Rate limiting
- WebDAV
- TLS and HTTP/2 (server push)

* Programming the Amazon Echo

#+BEGIN_SRC  clojure
  {:methods
   {:post
    {:consumes {:media-type "application/json" :charset "UTF-8"}
     :produces {:media-type "application/json" :charset "UTF-8"}
     :response
     (fn [ctx]
       (let [intent (-> ctx :body :request :intent :name)]
         {:version "1.0"
          :response
          {:outputSpeech
           {:type "PlainText"
            :text
            (case intent
              "Woodchuck" "if a woodchuck could chuck wood then I
               suppose a woodchuck would chuck as much wood as he could"
                                          ; Debug!
              (str "I'm a teapot, intent was " intent))}
           :shouldEndSession true}}))}}}
#+END_SRC

* Getting started with yada

- https://github.com/juxt/edge
- https://juxt.pro/yada

* Edge demo

- browser
- curl


* TODOs                                                            :noexport:
** TODO Add picture of Caxton printing press
** TODO Add picture of uri is the thing
